package network

import (
	"time"

	"github.com/patrickmn/go-cache"
)

// cacheManager implements CacheManager using go-cache
type cacheManager struct {
	cache *cache.Cache
}

// NewCacheManager creates a new cache manager
func NewCacheManager(defaultTTL time.Duration, cleanupInterval time.Duration) CacheManager {
	if defaultTTL == 0 {
		defaultTTL = DefaultCacheTTL
	}
	if cleanupInterval == 0 {
		cleanupInterval = 2 * time.Minute
	}

	return &cacheManager{
		cache: cache.New(defaultTTL, cleanupInterval),
	}
}

// Get retrieves a value from cache
func (c *cacheManager) Get(key string) (interface{}, bool) {
	return c.cache.Get(key)
}

// Set stores a value in cache with TTL
func (c *cacheManager) Set(key string, value interface{}, ttl time.Duration) {
	if ttl == 0 {
		ttl = DefaultCacheTTL
	}
	c.cache.Set(key, value, ttl)
}

// Delete removes a value from cache
func (c *cacheManager) Delete(key string) {
	c.cache.Delete(key)
}

// Clear removes all items from cache
func (c *cacheManager) Clear() {
	c.cache.Flush()
}

// ItemCount returns the number of items in cache
func (c *cacheManager) ItemCount() int {
	return c.cache.ItemCount()
}

// simpleCacheManager implements a simple in-memory cache without third-party dependencies
// This is a fallback implementation if go-cache is not available
type simpleCacheManager struct {
	items map[string]*cacheItem
}

type cacheItem struct {
	value      interface{}
	expiration int64
}

// NewSimpleCacheManager creates a simple cache manager without external dependencies
func NewSimpleCacheManager() CacheManager {
	return &simpleCacheManager{
		items: make(map[string]*cacheItem),
	}
}

func (s *simpleCacheManager) Get(key string) (interface{}, bool) {
	item, exists := s.items[key]
	if !exists {
		return nil, false
	}

	// Check expiration
	if item.expiration > 0 && time.Now().UnixNano() > item.expiration {
		delete(s.items, key)
		return nil, false
	}

	return item.value, true
}

func (s *simpleCacheManager) Set(key string, value interface{}, ttl time.Duration) {
	var expiration int64
	if ttl > 0 {
		expiration = time.Now().Add(ttl).UnixNano()
	}

	s.items[key] = &cacheItem{
		value:      value,
		expiration: expiration,
	}
}

func (s *simpleCacheManager) Delete(key string) {
	delete(s.items, key)
}

func (s *simpleCacheManager) Clear() {
	s.items = make(map[string]*cacheItem)
}

func (s *simpleCacheManager) ItemCount() int {
	return len(s.items)
}
